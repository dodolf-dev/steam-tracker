<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Steam Tracker — Grille de jeux</title>
    <style>
        :root{--gap:12px;--accent:#1b2838;--muted:#7b8a96;--bg:#0b1620}
        html,body{height:100%;margin:0;background:linear-gradient(180deg,#071019 0%, #536672 100%);background-size: cover;background-position: center;background-attachment: fixed;background-repeat: no-repeat;font-family:Inter,Segoe UI,Arial,sans-serif;color:#d7e6ef}
        
        /* Header fixe */
        .header-container {
            position: sticky;
            top: 0;
            z-index: 100;
            background: rgba(11, 22, 32, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #2a4758;
            padding: 15px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .container{max-width:1100px;margin:0 auto;padding:0 20px}
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .header-title {
            flex: 1;
            min-width: 300px;
        }
        
        .pepe-container {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #2a4758;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .pepe-gif {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .controls-container {
            display:flex;
            gap:8px;
            margin-bottom:12px;
            align-items:center;
            flex-wrap:wrap;
            width: 100%;
        }
        
        h1{
            margin:0;
            color:var(--accent);
            font-size: 24px;
        }
        
        /* Grille avec header fixe */
        .games-container {
            padding-top: 10px;
        }
        
        .grid{
            display:grid;
            grid-template-columns:40px 1fr 160px 160px 120px;
            gap:var(--gap);
            align-items:center;
        }
        
        .grid-header {
            position: sticky;
            top: 180px; /* Hauteur du header fixe */
            z-index: 90;
            background: rgba(11, 22, 32, 0.95);
            backdrop-filter: blur(10px);
            padding: 10px 0;
            margin-top: 10px;
            border-bottom: 1px solid #2a4758;
        }
        
        .grid .header{
            background:rgba(255,255,255,0.03);
            padding:10px 12px;
            border-radius:6px;
            font-weight:600;
            color:#bcd3e6;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .sort-indicator {
            font-size: 10px;
            opacity: 0.7;
            margin-left: 4px;
        }
        
        .cell{
            background:rgba(255,255,255,0.02);
            padding:10px;
            border-radius:6px;
            display:flex;
            align-items:center;
            gap:10px
        }
        
        .name-cell{
            position:relative;
            background:rgba(255,255,255,0.02);
            padding:10px;
            border-radius:6px;
            display:flex;
            align-items:center;
            min-height:92px;
            overflow:hidden;
        }
        
        .name-bg-image{
            position:absolute;
            right:0;
            top:0;
            bottom:0;
            width:270px;
            background-size:cover;
            background-position:center right;
            z-index:1;
            mask-image:linear-gradient(to right, transparent 0%, rgba(0,0,0,0.3) 30%, rgba(0,0,0,0.8) 70%, black 100%);
            -webkit-mask-image:linear-gradient(to right, transparent 0%, rgba(0,0,0,0.3) 30%, rgba(0,0,0,0.8) 70%, black 100%);
        }
        
        .name-content{
            position:relative;
            z-index:2;
            padding-right:80px;
            flex:1;
            display:flex;
            flex-direction:column;
            justify-content:center;
        }
        
        .game-title{
            font-size:16px;
            font-weight:600;
            color:#fff;
            margin-bottom:4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .game-checkbox {
            width: 16px;
            height: 16px;
            accent-color: #66c0f4;
        }
        
        .meta{font-size:13px;color:var(--muted);margin-bottom:6px}
        
        .price-old{text-decoration:line-through;color:#ffb3b3}
        .price-current{font-weight:700;color:#b6ffda}
        .discount{background:#1a7f57;color:white;padding:6px 8px;border-radius:6px;font-weight:700}

        .delete-btn {
            background: #5c2e2e;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 4px;
            align-self:flex-start;
        }
        
        .delete-btn:hover {
            background: #7a3a3a;
        }
        
        .retry-btn {
            background: #2a5c47;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 4px;
            margin-left: 4px;
            align-self:flex-start;
        }
        
        .retry-btn:hover {
            background: #357a5c;
        }

        .menu-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .expand-btn {
            background: transparent;
            border: none;
            color: #66c0f4;
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 18px;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .expand-btn:hover {
            background: rgba(102, 192, 244, 0.1);
        }

        .dlc-progress-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #1a7f57;
            color: white;
            border-radius: 10px;
            font-size: 9px;
            font-weight: 700;
            padding: 2px 4px;
            min-width: 16px;
            text-align: center;
        }

        .dlc-loading-indicator {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 12px;
            height: 12px;
            border: 2px solid #2a4758;
            border-top-color: #66c0f4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .expanded-row {
            grid-column: 2 / -1;
            background: rgba(11, 22, 32, 0.95);
            border: 1px solid #2a4758;
            border-radius: 6px;
            margin-top: 8px;
            padding: 16px;
            display: none;
            max-height: 500px;
            overflow-y: auto;
        }

        .expanded-row.show {
            display: block;
        }

        .versions-container {
            margin-top: 8px;
        }

        .versions-section {
            margin-bottom: 16px;
        }

        .versions-section h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #66c0f4;
            border-bottom: 1px solid #2a4758;
            padding-bottom: 6px;
        }

        .version-item {
            padding: 8px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            border-left: 3px solid #2a4758;
            animation: fadeIn 0.3s ease-in;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .version-item.main-game {
            border-left-color: #1a7f57;
        }

        .version-item.dlc {
            border-left-color: #2a4758;
        }

        .version-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .version-checkbox {
            width: 16px;
            height: 16px;
            accent-color: #66c0f4;
        }

        .version-name {
            font-weight: 600;
            color: #fff;
            font-size: 14px;
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .version-price-container {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-left: 24px;
        }

        .version-old-price {
            text-decoration: line-through;
            color: #ffb3b3;
            font-size: 13px;
        }

        .version-current-price {
            font-weight: 700;
            color: #b6ffda;
            font-size: 13px;
        }

        .version-discount {
            background: #1a7f57;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .version-free {
            background: #2a4758;
            color: #66c0f4;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .version-error {
            background: #ff8c42;
            color: #662900;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .price-na {
            color: #9fb0bd;
            font-size: 13px;
        }

        .loading-versions {
            color: #9fb0bd;
            font-size: 13px;
            padding: 12px;
            text-align: center;
        }

        .error-versions {
            color: #ff6b6b;
            font-size: 13px;
            padding: 12px;
            text-align: center;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #2a4758;
            border-radius: 2px;
            margin: 8px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #1a7f57;
            width: 0%;
            transition: width 0.3s ease;
        }

        .dlc-stats {
            font-size: 12px;
            color: #9fb0bd;
            text-align: center;
            margin-top: 4px;
        }

        .dlc-retry-btn {
            background: #ff8c42;
            color: white;
            border: none;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
            margin-left: 8px;
        }

        .dlc-retry-btn:hover {
            background: #ff9e5e;
        }

        .success { color: #66c0f4; }
        .error { color: #ff6b6b; }
        .warning { color: #ffd166; }
        
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #2a4758;
            border-top-color: #66c0f4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        input[type="number"] {
            padding:8px;
            border-radius:6px;
            border:1px solid rgba(255,255,255,0.06);
            background:rgba(255,255,255,0.05);
            color:inherit;
            width:200px;
            transition: all 0.2s;
        }
        
        input[type="number"]:focus {
            outline: none;
            border-color: #66c0f4;
            box-shadow: 0 0 0 2px rgba(102, 192, 244, 0.1);
        }
        
        button#addGameBtn {
            padding:8px 12px;
            border-radius:6px;
            border:0;
            background:#2a4758;
            color:#e6f7f0;
            font-weight:700;
            cursor:pointer;
            transition: all 0.2s;
        }
        
        button#addGameBtn:hover {
            background:#1b2838;
        }
        
        button#clearBtn {
            padding:8px 12px;
            border-radius:6px;
            border:1px solid #5c2e2e;
            background:transparent;
            color:#e6f7f0;
            font-weight:700;
            cursor:pointer;
            transition: all 0.2s;
        }
        
        button#clearBtn:hover {
            background:rgba(92, 46, 46, 0.2);
        }
        
        .selection-stats {
            margin-left: 12px;
            font-size: 13px;
            color: #66c0f4;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #status {
            color:#9fb0bd;
            font-size:13px;
            margin-left:6px;
            display:flex;
            align-items:center;
            min-height: 24px;
        }
        
        .version-indicator {
            font-size: 11px;
            color: #66c0f4;
            background: rgba(102, 192, 244, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width:800px){
            .header-content {
                flex-direction: column;
                align-items: stretch;
            }
            
            .header-title {
                min-width: auto;
            }
            
            .pepe-container {
                align-self: flex-end;
                position: absolute;
                top: 15px;
                right: 20px;
            }
            
            .grid{grid-template-columns:40px 1fr 110px 110px 90px}
            .name-cell{min-height:80px;}
            .name-bg-image{width:150px;}
            .expanded-row {
                grid-column: 2 / -1;
            }
            
            .grid-header {
                top: 220px;
            }
        }
        
        @media (max-width:560px){
            .grid{grid-template-columns:1fr}
            .grid .header:nth-child(n+2), 
            .cell:nth-child(n+2),
            .menu-container{display:none}
            .name-bg-image{width:120px;}
            .expanded-row {
                grid-column: 1 / -1;
                margin: 8px 0;
            }
            
            .grid-header {
                top: 240px;
            }
        }
    </style>
</head>
<body>
    <!-- Header fixe -->
    <div class="header-container">
        <div class="container">
            <div class="header-content">
                <div class="header-title">
                    <h1>Liste de jeux Steam</h1>
                    <div class="controls-container">
                        <input id="gameIdInput" type="number" placeholder="Entrez l'ID Steam (ex: 227300)" />
                        <button id="addGameBtn">Ajouter un jeu</button>
                        <button id="clearBtn">Effacer tout</button>
                        <div class="selection-stats" id="selectionStats"></div>
                        <div id="status"></div>
                    </div>
                </div>
                <!-- Conteneur Pepe -->
                <div class="pepe-container">
                    <img id="pepeGif" src="pepe-the-frog-sitting-chillin.gif" class="pepe-gif" alt="Pepe status">
                </div>
            </div>
            
            <!-- En-têtes des colonnes -->
            <div class="grid-header">
                <div class="grid" id="gridHeaders">
                    <div class="header"></div>
                    <div class="header sortable" data-sort="name">
                        Nom <span class="sort-indicator"></span>
                    </div>
                    <div class="header sortable" data-sort="original-price">
                        Prix original <span class="sort-indicator"></span>
                    </div>
                    <div class="header sortable" data-sort="current-price">
                        Prix actuel <span class="sort-indicator"></span>
                    </div>
                    <div class="header sortable" data-sort="discount">
                        Réduction <span class="sort-indicator"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Contenu principal avec défilement -->
    <div class="container games-container">
        <div class="grid" id="gamesGrid">
            <!-- Les jeux seront ajoutés ici -->
        </div>
    </div>

    <script>
// Configuration optimisée pour la vitesse
const CONFIG = {
    gameTimeout: 6000,
    dlcTimeout: 5000,
    gameMaxRetries: 1,
    dlcMaxRetries: 0,
    retryDelay: 800,
    useProxy: true,
    proxies: [
        'https://api.allorigins.win/raw?url=',
        'https://corsproxy.io/?',
        'https://api.codetabs.com/v1/proxy?quest='
    ],
    dlcBatchSize: 8,
    dlcDelay: 200,
    directFallback: true
};

// URLs des GIFs Pepe
const PEPE_GIFS = {
    idle: 'pepe-the-frog-sitting-chillin.gif', // Pepe chillin
    loading: 'pepe-pepe-chat.gif' // Pepe chat (recherche)
};

// Variables pour suivre l'état du chargement
let isLoading = false;
let activeRequests = 0;
let pepeGifElement = null;

// Variables de tri
let currentSort = { field: 'name', direction: 'asc' };

// Cache global
const GLOBAL_CACHE = {
    games: new Map(),
    dlcs: new Map(),
    packages: new Map(),
    
    getGame(appId) {
        const cached = this.games.get(appId);
        if (cached && Date.now() - cached.timestamp < 1800000) {
            return cached.data;
        }
        return null;
    },
    
    setGame(appId, data) {
        this.games.set(appId, {
            data: data,
            timestamp: Date.now()
        });
    },
    
    getDLC(dlcId) {
        const cached = this.dlcs.get(dlcId);
        if (cached && Date.now() - cached.timestamp < 3600000) {
            return cached.data;
        }
        return null;
    },
    
    setDLC(dlcId, data) {
        this.dlcs.set(dlcId, {
            data: data,
            timestamp: Date.now()
        });
    },
    
    getPackage(packageId) {
        const cached = this.packages.get(packageId);
        if (cached && Date.now() - cached.timestamp < 1800000) {
            return cached.data;
        }
        return null;
    },
    
    setPackage(packageId, data) {
        this.packages.set(packageId, {
            data: data,
            timestamp: Date.now()
        });
    },
    
    clearOldEntries() {
        const now = Date.now();
        for (const [key, value] of this.games.entries()) {
            if (now - value.timestamp > 1800000) {
                this.games.delete(key);
            }
        }
        for (const [key, value] of this.dlcs.entries()) {
            if (now - value.timestamp > 3600000) {
                this.dlcs.delete(key);
            }
        }
        for (const [key, value] of this.packages.entries()) {
            if (now - value.timestamp > 1800000) {
                this.packages.delete(key);
            }
        }
    }
};

setInterval(() => GLOBAL_CACHE.clearOldEntries(), 300000);

const games = [
    {
        header_image: 'https://cdn.cloudflare.steamstatic.com/steam/apps/227300/header.jpg',
        name: 'Loading error',
        price_initial_cents: 1,
        price_final_cents: 1,
        discount_percent: 1,
        appid: 1,
        steam_appid: 1,
        is_free: false,
        last_updated: new Date().toISOString(),
        selected: false,
        versions: [],
        selectedVersion: null,
        selectedVersionData: null // Nouveau champ pour stocker les données de la version sélectionnée
    }
];

// Fonctions de gestion des GIFs Pepe
function updatePepeGif() {
    if (!pepeGifElement) {
        pepeGifElement = document.getElementById('pepeGif');
    }
    
    if (activeRequests > 0 || isLoading) {
        // Chargement en cours
        pepeGifElement.src = PEPE_GIFS.loading;
    } else {
        // Aucun chargement en cours
        pepeGifElement.src = PEPE_GIFS.idle;
    }
}

function startLoading() {
    activeRequests++;
    isLoading = true;
    updatePepeGif();
}

function stopLoading() {
    activeRequests = Math.max(0, activeRequests - 1);
    if (activeRequests === 0) {
        isLoading = false;
    }
    updatePepeGif();
}

function showStatus(message, type = 'info') {
    const statusEl = document.getElementById('status');
    statusEl.innerHTML = '';
    
    if (type === 'loading') {
        statusEl.innerHTML = `<span class="loading"></span>${message}`;
        statusEl.className = '';
    } else if (type === 'success') {
        statusEl.innerHTML = `✓ ${message}`;
        statusEl.className = 'success';
    } else if (type === 'error') {
        statusEl.innerHTML = `✗ ${message}`;
        statusEl.className = 'error';
    } else if (type === 'warning') {
        statusEl.innerHTML = `⚠ ${message}`;
        statusEl.className = 'warning';
    } else {
        statusEl.textContent = message;
        statusEl.className = '';
    }
    
    if (type !== 'loading') {
        setTimeout(() => {
            if (statusEl.textContent.includes(message.substring(0, 20))) {
                statusEl.textContent = '';
                statusEl.className = '';
            }
        }, 5000);
    }
}

async function fetchWithTimeoutAndRetry(url, options = {}, retryCount = 0, maxRetries = 1, timeout = 6000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch(url, {
            ...options,
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        return response;
    } catch (error) {
        clearTimeout(timeoutId);
        
        if (retryCount < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, CONFIG.retryDelay));
            return fetchWithTimeoutAndRetry(url, options, retryCount + 1, maxRetries, timeout);
        }
        
        throw error;
    }
}

function createFallbackDLC(dlcId, error = false) {
    return {
        appid: dlcId,
        name: `DLC ${dlcId}`,
        header_image: null,
        price_overview: null,
        is_free: false,
        error: error,
        last_attempt: Date.now(),
        selected: false
    };
}

async function tryFetchSteamAPI(dlcId, proxy = null) {
    const steamUrl = `https://store.steampowered.com/api/appdetails?appids=${dlcId}&cc=fr&l=fr&filters=basic,price_overview`;
    const url = proxy ? proxy + encodeURIComponent(steamUrl) : steamUrl;
    
    try {
        const response = await fetchWithTimeoutAndRetry(
            url, 
            {
                headers: { 
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Accept': 'application/json',
                    'Accept-Language': 'fr-FR,fr;q=0.9',
                    'Referer': 'https://store.steampowered.com/'
                },
                timeout: CONFIG.dlcTimeout
            },
            0,
            CONFIG.dlcMaxRetries,
            CONFIG.dlcTimeout
        );
        
        if (!response.ok) {
            return null;
        }
        
        const data = await response.json();
        
        if (data[dlcId]?.success) {
            const dlcData = data[dlcId].data;
            
            return {
                appid: dlcId,
                name: dlcData.name || `Contenu ${dlcId}`,
                header_image: dlcData.header_image || null,
                price_overview: dlcData.price_overview || null,
                is_free: dlcData.is_free || false,
                type: dlcData.type || 'unknown',
                error: false,
                last_attempt: Date.now(),
                selected: false
            };
        } else {
            return createFallbackDLC(dlcId, true);
        }
    } catch (error) {
        return null;
    }
}

async function fetchSingleDLC(dlcId, forceRetry = false) {
    if (!forceRetry) {
        const cached = GLOBAL_CACHE.getDLC(dlcId);
        if (cached) {
            if (cached.error && Date.now() - cached.last_attempt < 300000) {
            } else if (!cached.error) {
                return cached;
            }
        }
    }
    
    for (const proxy of CONFIG.proxies) {
        const result = await tryFetchSteamAPI(dlcId, proxy);
        if (result) {
            GLOBAL_CACHE.setDLC(dlcId, result);
            return result;
        }
    }
    
    if (CONFIG.directFallback) {
        const result = await tryFetchSteamAPI(dlcId, null);
        if (result) {
            GLOBAL_CACHE.setDLC(dlcId, result);
            return result;
        }
    }
    
    const fallback = createFallbackDLC(dlcId, true);
    GLOBAL_CACHE.setDLC(dlcId, fallback);
    return fallback;
}

// NOUVELLE FONCTION : Récupérer les données d'un package
async function fetchPackageData(packageId) {
    if (!packageId) return null;
    
    const cached = GLOBAL_CACHE.getPackage(packageId);
    if (cached) {
        return cached;
    }
    
    const steamUrl = `https://store.steampowered.com/api/packagedetails?packageids=${packageId}&cc=fr&l=fr`;
    
    for (const proxy of CONFIG.proxies) {
        try {
            const url = proxy + encodeURIComponent(steamUrl);
            const response = await fetchWithTimeoutAndRetry(
                url,
                {
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                        'Accept': 'application/json',
                        'Accept-Language': 'fr-FR,fr;q=0.9',
                        'Referer': 'https://store.steampowered.com/'
                    },
                    timeout: CONFIG.gameTimeout
                },
                0,
                CONFIG.gameMaxRetries,
                CONFIG.gameTimeout
            );
            
            if (!response.ok) {
                continue;
            }
            
            const data = await response.json();
            
            if (!data[packageId]) {
                continue;
            }
            
            const packageData = data[packageId];
            
            if (!packageData.success) {
                continue;
            }
            
            GLOBAL_CACHE.setPackage(packageId, packageData.data);
            return packageData.data;
            
        } catch (error) {
            continue;
        }
    }
    
    if (CONFIG.directFallback) {
        try {
            const response = await fetchWithTimeoutAndRetry(
                steamUrl,
                {
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                        'Accept': 'application/json',
                        'Accept-Language': 'fr-FR,fr;q=0.9',
                        'Referer': 'https://store.steampowered.com/'
                    },
                    timeout: CONFIG.gameTimeout
                },
                0,
                CONFIG.gameMaxRetries,
                CONFIG.gameTimeout
            );
            
            if (response.ok) {
                const data = await response.json();
                if (data[packageId]?.success) {
                    GLOBAL_CACHE.setPackage(packageId, data[packageId].data);
                    return data[packageId].data;
                }
            }
        } catch (error) {
        }
    }
    
    return null;
}

// MODIFIÉ : Récupérer les packages associés à un jeu
async function fetchGamePackages(appId) {
    startLoading();
    try {
        // Base de données de packages connus
        const knownPackages = {
            '1551360': [ // Forza Horizon 5
                { id: 547831, name: 'Forza Horizon 5 - Standard Edition' },
                { id: 596608, name: 'Forza Horizon 5 - Deluxe Edition' },
                { id: 596609, name: 'Forza Horizon 5 - Premium Edition' }
            ],
            '227300': [ // Euro Truck Simulator 2
                { id: 227301, name: 'Euro Truck Simulator 2 - Going East!' },
                { id: 227302, name: 'Euro Truck Simulator 2 - Scandinavia' }
            ],
            '730': [ // Counter-Strike: Global Offensive
                { id: 10539, name: 'Counter-Strike: Global Offensive - Prime Status Upgrade' }
            ],
            '578080': [ // PUBG
                { id: 1089550, name: 'PLAYERUNKNOWN\'S BATTLEGROUNDS - Survivor Pass: Vikendi' }
            ],
            '252950': [ // Rocket League
                { id: 358692, name: 'Rocket League® - Supersonic Fury DLC Pack' }
            ],
            '271590': [ // Grand Theft Auto V
                { id: 349830, name: 'Grand Theft Auto V - Great White Shark Cash Card' },
                { id: 349831, name: 'Grand Theft Auto V - Whale Shark Cash Card' },
                { id: 349832, name: 'Grand Theft Auto V - Megalodon Shark Cash Card' }
            ]
        };
        
        const packages = knownPackages[appId] || [];
        const packageDetails = [];
        
        // Récupérer les détails de chaque package
        for (const pkg of packages) {
            try {
                const packageData = await fetchPackageData(pkg.id);
                if (packageData) {
                    packageDetails.push({
                        packageid: pkg.id,
                        name: packageData.name || pkg.name,
                        price_in_cents_with_discount: packageData.price?.final || 0,
                        percent_savings: packageData.price?.discount_percent || 0,
                        is_free_license: packageData.price?.final === 0 || false,
                        selected: false
                    });
                }
            } catch (error) {
                // Si on ne peut pas récupérer les données, on utilise les infos de base
                packageDetails.push({
                    packageid: pkg.id,
                    name: pkg.name,
                    price_in_cents_with_discount: 0,
                    percent_savings: 0,
                    is_free_license: false,
                    selected: false
                });
            }
        }
        
        return packageDetails;
    } finally {
        stopLoading();
    }
}

// NOUVELLE FONCTION : Mettre à jour l'affichage du jeu avec les données de la version sélectionnée
function updateGameDisplayWithVersion(game, versionData) {
    const gameIndex = games.findIndex(g => g.appid === game.appid);
    if (gameIndex === -1) return;
    
    // Stocker les données de la version sélectionnée
    games[gameIndex].selectedVersionData = versionData;
    
    // Mettre à jour l'affichage
    refreshGrid();
    saveGamesToLocalStorage();
}

// MODIFIÉ : Fonction pour sélectionner une version
function selectVersion(gameAppId, version) {
    const gameIndex = games.findIndex(g => g.appid === gameAppId);
    if (gameIndex === -1) return;
    
    games[gameIndex].selectedVersion = version.packageid;
    games[gameIndex].selectedVersionData = version;
    
    // Mettre à jour l'affichage
    refreshGrid();
    saveGamesToLocalStorage();
    updateSelectionStats();
}

// MODIFIÉ : Fonction pour désélectionner une version
function deselectVersion(gameAppId) {
    const gameIndex = games.findIndex(g => g.appid === gameAppId);
    if (gameIndex === -1) return;
    
    games[gameIndex].selectedVersion = null;
    games[gameIndex].selectedVersionData = null;
    
    // Mettre à jour l'affichage
    refreshGrid();
    saveGamesToLocalStorage();
    updateSelectionStats();
}

// MODIFIÉ : Récupérer les versions du jeu
async function fetchGameVersions(appId, onProgress) {
    startLoading();
    try {
        const gameIndex = games.findIndex(g => 
            String(g.appid) === String(appId) || 
            String(g.steam_appid) === String(appId)
        );
        
        if (gameIndex === -1) {
            return { 
                mainGame: null, 
                dlcs: [], 
                allDlcIds: [],
                totalDlcCount: 0,
                loadedDlcCount: 0,
                error: 'Jeu non trouvé',
                versions: []
            };
        }
        
        const game = games[gameIndex];
        
        // Si on n'a pas encore chargé les versions, on les charge
        if (!game.versions || game.versions.length === 0) {
            game.versions = await fetchGamePackages(appId);
            saveGamesToLocalStorage();
        }
        
        // Chargement des DLC
        if (game.dlc_ids && game.dlc_ids.length > 0 && !game.dlc_loading) {
            game.dlc_loading = true;
            
            const dlcDetails = await loadDLCsProgressively(
                game.dlc_ids,
                (loaded, total) => {
                    game.loaded_dlc_count = loaded;
                    if (onProgress) onProgress(loaded, total);
                },
                (batch) => {
                    if (!game.dlc_data) game.dlc_data = [];
                    game.dlc_data.push(...batch);
                    updateDLCBadge(appId, game.loaded_dlc_count, game.dlc_count);
                }
            );
            
            game.dlc_data = dlcDetails;
            game.dlc_loading = false;
            saveGamesToLocalStorage();
        }
        
        return {
            mainGame: {
                type: 'main',
                name: game.name,
                appid: appId,
                price: game.price_initial_cents ? {
                    initial: game.price_initial_cents,
                    final: game.price_final_cents,
                    discount_percent: game.discount_percent
                } : null,
                is_free: game.is_free,
                versions: game.versions || [],
                selectedVersion: game.selectedVersion,
                selectedVersionData: game.selectedVersionData
            },
            dlcs: game.dlc_data || [],
            allDlcIds: game.dlc_ids || [],
            totalDlcCount: game.dlc_count || 0,
            loadedDlcCount: game.loaded_dlc_count || 0,
            hasMoreDLC: false
        };
        
    } catch (error) {
        return { 
            mainGame: null, 
            dlcs: [], 
            allDlcIds: [],
            totalDlcCount: 0,
            loadedDlcCount: 0,
            error: error.message,
            versions: []
        };
    } finally {
        stopLoading();
    }
}

// Fonction pour charger les DLC progressivement
async function loadDLCsProgressively(dlcIds, onProgress, onBatchComplete) {
    if (!dlcIds || dlcIds.length === 0) {
        onProgress(0, 0);
        return [];
    }
    
    const batchSize = CONFIG.dlcBatchSize;
    const dlcDetails = [];
    
    const cachedResults = [];
    const remainingIds = [];
    
    for (const dlcId of dlcIds) {
        const cached = GLOBAL_CACHE.getDLC(dlcId);
        if (cached && !cached.error) {
            cachedResults.push(cached);
        } else {
            remainingIds.push(dlcId);
        }
    }
    
    dlcDetails.push(...cachedResults);
    onProgress(dlcDetails.length, dlcIds.length);
    
    if (remainingIds.length === 0) {
        return dlcDetails;
    }
    
    const batches = [];
    for (let i = 0; i < remainingIds.length; i += batchSize) {
        batches.push(remainingIds.slice(i, i + batchSize));
    }
    
    const batchPromises = batches.map(async (batch) => {
        const batchPromises = batch.map(dlcId => fetchSingleDLC(dlcId));
        
        try {
            const batchResults = await Promise.allSettled(batchPromises);
            const successful = batchResults
                .filter(r => r.status === 'fulfilled')
                .map(r => r.value);
            
            dlcDetails.push(...successful);
            onProgress(dlcDetails.length, dlcIds.length);
            
            if (onBatchComplete) {
                onBatchComplete(successful);
            }
        } catch (error) {
            // Ignorer les erreurs de lot
        }
    });
    
    await Promise.allSettled(batchPromises);
    
    return dlcDetails;
}

// Fonction pour récupérer les données du jeu principal
async function getSteamGameDataWithPreload(appId, options = {}) {
    const { 
        timeout = CONFIG.gameTimeout
    } = options;
    
    const cachedGame = GLOBAL_CACHE.getGame(appId);
    if (cachedGame) {
        return cachedGame;
    }
    
    // On récupère seulement les données de base du jeu
    const steamUrl = `https://store.steampowered.com/api/appdetails?appids=${appId}&cc=fr&l=fr&filters=basic,price_overview`;
    
    for (const proxy of CONFIG.proxies) {
        try {
            const url = proxy + encodeURIComponent(steamUrl);
            const response = await fetchWithTimeoutAndRetry(
                url,
                {
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                        'Accept': 'application/json',
                        'Accept-Language': 'fr-FR,fr;q=0.9',
                        'Referer': 'https://store.steampowered.com/'
                    },
                    timeout: timeout
                },
                0,
                CONFIG.gameMaxRetries,
                timeout
            );
            
            if (!response.ok) {
                continue;
            }
            
            const data = await response.json();
            
            if (!data[appId]) {
                continue;
            }
            
            const gameData = data[appId];
            
            if (!gameData.success) {
                continue;
            }
            
            const dlcIds = gameData.data.dlc || [];
            
            const extractedData = {
                success: gameData.success,
                data: {
                    name: gameData.data.name,
                    steam_appid: gameData.data.steam_appid,
                    required_age: gameData.data.required_age,
                    is_free: gameData.data.is_free,
                    controller_support: gameData.data.controller_support,
                    header_image: gameData.data.header_image || null,
                    dlc_ids: dlcIds,
                    dlc_count: dlcIds.length,
                    loaded_dlc_count: 0,
                    versions: [], // On initialise un tableau vide, les versions seront chargées plus tard
                    selectedVersion: null,
                    selectedVersionData: null
                },
                dlc_data: [],
                price_overview: gameData.data.price_overview || null,
                last_updated: new Date().toISOString()
            };
            
            GLOBAL_CACHE.setGame(appId, extractedData);
            return extractedData;
            
        } catch (error) {
            continue;
        }
    }
    
    if (CONFIG.directFallback) {
        try {
            const response = await fetchWithTimeoutAndRetry(
                steamUrl,
                {
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                        'Accept': 'application/json',
                        'Accept-Language': 'fr-FR,fr;q=0.9',
                        'Referer': 'https://store.steampowered.com/'
                    },
                    timeout: timeout
                },
                0,
                CONFIG.gameMaxRetries,
                timeout
            );
            
            if (response.ok) {
                const data = await response.json();
                
                if (data[appId]?.success) {
                    const gameData = data[appId].data;
                    const dlcIds = gameData.dlc || [];
                    
                    const extractedData = {
                        success: gameData.success,
                        data: {
                            name: gameData.data.name,
                            steam_appid: gameData.data.steam_appid,
                            required_age: gameData.data.required_age,
                            is_free: gameData.data.is_free,
                            controller_support: gameData.data.controller_support,
                            header_image: gameData.data.header_image || null,
                            dlc_ids: dlcIds,
                            dlc_count: dlcIds.length,
                            loaded_dlc_count: 0,
                            versions: [],
                            selectedVersion: null,
                            selectedVersionData: null
                        },
                        dlc_data: [],
                        price_overview: gameData.data.price_overview || null,
                        last_updated: new Date().toISOString()
                    };
                    
                    GLOBAL_CACHE.setGame(appId, extractedData);
                    return extractedData;
                }
            }
        } catch (error) {
        }
    }
    
    return null;
}

async function fetchGameDataWithPreload(appId) {
    startLoading();
    try {
        const gameData = await getSteamGameDataWithPreload(appId);
        
        if (!gameData) {
            return createFallbackGame(appId);
        }
        
        const priceOverview = gameData.price_overview;
        const isFree = gameData.data.is_free || 
                       (priceOverview && priceOverview.final === 0) || 
                       (!priceOverview && gameData.data.type === 'game');
        
        const formattedData = {
            appid: appId,
            steam_appid: gameData.data.steam_appid || appId,
            name: gameData.data.name || `Jeu ID: ${appId}`,
            header_image: gameData.data.header_image || 'https://store.cloudflare.steamstatic.com/public/shared/images/header/globalheader_logo.png',
            is_free: isFree,
            price_initial_cents: priceOverview ? priceOverview.initial : null,
            price_final_cents: priceOverview ? priceOverview.final : (isFree ? 0 : null),
            discount_percent: priceOverview ? priceOverview.discount_percent : 0,
            dlc_data: [],
            dlc_ids: gameData.data.dlc_ids || [],
            dlc_count: gameData.data.dlc_count || 0,
            loaded_dlc_count: 0,
            versions: gameData.data.versions || [],
            selectedVersion: gameData.data.selectedVersion || null,
            selectedVersionData: gameData.data.selectedVersionData || null,
            selected: false,
            last_updated: gameData.last_updated || new Date().toISOString(),
            dlc_loading: false
        };
        
        return formattedData;
    } finally {
        stopLoading();
    }
}

function hasGame(appid){
    return games.some(g => String(g.appid) === String(appid) || String(g.steam_appid) === String(appid));
}

async function fetchBasicGameData(appId) {
    startLoading();
    try {
        const cached = GLOBAL_CACHE.getGame(appId);
        if (cached) {
            return {
                appid: appId,
                steam_appid: cached.data.steam_appid || appId,
                name: cached.data.name || `Jeu ID: ${appId}`,
                header_image: cached.data.header_image || null,
                is_free: cached.data.is_free || false,
                price_initial_cents: cached.price_overview?.initial || null,
                price_final_cents: cached.price_overview?.final || (cached.data.is_free ? 0 : null),
                discount_percent: cached.price_overview?.discount_percent || 0,
                dlc_count: cached.data.dlc_count || 0,
                dlc_ids: cached.data.dlc_ids || [],
                loaded_dlc_count: 0,
                dlc_data: [],
                versions: cached.data.versions || [],
                selectedVersion: cached.data.selectedVersion || null,
                selectedVersionData: cached.data.selectedVersionData || null,
                selected: false,
                dlc_loading: false,
                last_updated: new Date().toISOString()
            };
        }
        
        const steamUrl = `https://store.steampowered.com/api/appdetails?appids=${appId}&cc=fr&l=fr&filters=basic,price_overview`;
        
        for (const proxy of CONFIG.proxies) {
            try {
                const url = proxy + encodeURIComponent(steamUrl);
                const response = await fetchWithTimeoutAndRetry(
                    url,
                    {
                        headers: { 
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                            'Accept': 'application/json',
                            'Accept-Language': 'fr-FR,fr;q=0.9',
                            'Referer': 'https://store.steampowered.com/'
                        },
                        timeout: 4000
                    },
                    0,
                    0,
                    4000
                );
                
                if (response.ok) {
                    const data = await response.json();
                    if (data[appId]?.success) {
                        const gameData = data[appId].data;
                        const priceOverview = gameData.price_overview;
                        
                        return {
                            appid: appId,
                            steam_appid: gameData.steam_appid || appId,
                            name: gameData.name || `Jeu ID: ${appId}`,
                            header_image: gameData.header_image || null,
                            is_free: gameData.is_free || false,
                            price_initial_cents: priceOverview?.initial || null,
                            price_final_cents: priceOverview?.final || (gameData.is_free ? 0 : null),
                            discount_percent: priceOverview?.discount_percent || 0,
                            dlc_count: gameData.dlc?.length || 0,
                            dlc_ids: gameData.dlc || [],
                            loaded_dlc_count: 0,
                            dlc_data: [],
                            versions: [], // Versions vides pour l'instant
                            selectedVersion: null,
                            selectedVersionData: null,
                            selected: false,
                            dlc_loading: false,
                            last_updated: new Date().toISOString()
                        };
                    }
                }
            } catch (error) {
                continue;
            }
        }
        
        try {
            const response = await fetchWithTimeoutAndRetry(
                steamUrl,
                {
                    headers: { 
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                        'Accept': 'application/json',
                        'Accept-Language': 'fr-FR,fr;q=0.9',
                        'Referer': 'https://store.steampowered.com/'
                    },
                    timeout: 4000
                },
                0,
                0,
                4000
            );
            
            if (response.ok) {
                const data = await response.json();
                if (data[appId]?.success) {
                    const gameData = data[appId].data;
                    const priceOverview = gameData.price_overview;
                    
                    return {
                        appid: appId,
                        steam_appid: gameData.steam_appid || appId,
                        name: gameData.name || `Jeu ID: ${appId}`,
                        header_image: gameData.header_image || null,
                        is_free: gameData.is_free || false,
                        price_initial_cents: priceOverview?.initial || null,
                        price_final_cents: priceOverview?.final || (gameData.is_free ? 0 : null),
                        discount_percent: priceOverview?.discount_percent || 0,
                        dlc_count: gameData.dlc?.length || 0,
                        dlc_ids: gameData.dlc || [],
                        loaded_dlc_count: 0,
                        dlc_data: [],
                        versions: [], // Versions vides pour l'instant
                        selectedVersion: null,
                        selectedVersionData: null,
                        selected: false,
                        dlc_loading: false,
                        last_updated: new Date().toISOString()
                    };
                }
            }
        } catch (error) {
        }
        
        return createFallbackGame(appId);
    } finally {
        stopLoading();
    }
}

function createFallbackGame(appId, fromSteam = false) {
    const gameName = fromSteam ? `Jeu ID: ${appId} (Indisponible)` : `Jeu ID: ${appId} (Hors ligne)`;
    
    return {
        appid: appId,
        steam_appid: appId,
        name: gameName,
        header_image: 'https://store.cloudflare.steamstatic.com/public/shared/images/header/globalheader_logo.png',
        is_free: false,
        price_initial_cents: null,
        price_final_cents: null,
        discount_percent: 0,
        unavailable: true,
        offline: !fromSteam,
        dlc_count: 0,
        dlc_data: [],
        versions: [],
        selectedVersion: null,
        selectedVersionData: null,
        selected: false,
        last_updated: new Date().toISOString()
    };
}

function updateDLCBadge(appId, loaded, total) {
    const expandBtn = document.querySelector(`[data-appid="${appId}"]`);
    if (expandBtn) {
        let badge = expandBtn.querySelector('.dlc-progress-badge');
        if (!badge && total > 0) {
            badge = document.createElement('span');
            badge.className = 'dlc-progress-badge';
            expandBtn.appendChild(badge);
        }
        
        if (badge) {
            if (loaded < total) {
                badge.textContent = `${loaded}/${total}`;
                badge.style.background = '#2a4758';
            } else {
                badge.textContent = total;
                badge.style.background = '#1a7f57';
            }
        }
        
        const nameCell = document.querySelector(`[data-game-id="${appId}"]`);
        if (nameCell) {
            const meta = nameCell.querySelector('.meta');
            if (meta) {
                const metaText = meta.textContent;
                if (metaText.includes('DLC:')) {
                    const newMeta = metaText.replace(/DLC: \d+\/\d+/, `DLC: ${loaded}/${total}`);
                    meta.textContent = newMeta;
                    
                    if (loaded === total) {
                        const finalMeta = newMeta.replace(' (chargement...)', '');
                        meta.textContent = finalMeta;
                    }
                }
            }
        }
    }
}

async function retrySingleDLC(gameAppId, dlcId) {
    showStatus(`Nouvelle tentative pour DLC ${dlcId}...`, 'loading');
    startLoading();
    
    try {
        const gameIndex = games.findIndex(g => 
            String(g.appid) === String(gameAppId) || 
            String(g.steam_appid) === String(gameAppId)
        );
        
        if (gameIndex === -1) {
            showStatus('Jeu non trouvé', 'error');
            return;
        }
        
        const game = games[gameIndex];
        const dlcIndex = game.dlc_data?.findIndex(d => String(d.appid) === String(dlcId));
        
        if (dlcIndex === -1 || !game.dlc_data) {
            showStatus('DLC non trouvé', 'error');
            return;
        }
        
        game.dlc_data[dlcIndex].loading = true;
        
        const expandedRow = document.getElementById(`expanded-${gameAppId}`);
        if (expandedRow && expandedRow.classList.contains('show')) {
            const panelContent = createVersionsPanel(game, {
                mainGame: {
                    type: 'main',
                    name: game.name,
                    appid: gameAppId,
                    price: game.price_initial_cents ? {
                        initial: game.price_initial_cents,
                        final: game.price_final_cents,
                        discount_percent: game.discount_percent
                    } : null,
                    is_free: game.is_free,
                    versions: game.versions || [],
                    selectedVersion: game.selectedVersion,
                    selectedVersionData: game.selectedVersionData
                },
                dlcs: game.dlc_data || [],
                allDlcIds: game.dlc_ids || [],
                totalDlcCount: game.dlc_count || 0,
                loadedDlcCount: game.loaded_dlc_count || 0,
                hasMoreDLC: false
            }, expandedRow);
            expandedRow.innerHTML = '';
            expandedRow.appendChild(panelContent);
        }
        
        const newDLCData = await fetchSingleDLC(dlcId, true);
        
        game.dlc_data[dlcIndex] = newDLCData;
        game.dlc_data[dlcIndex].loading = false;
        
        if (!newDLCData.error) {
            game.loaded_dlc_count = game.dlc_data.filter(d => !d.error).length;
        }
        
        saveGamesToLocalStorage();
        updateDLCBadge(gameAppId, game.loaded_dlc_count, game.dlc_count);
        
        if (expandedRow && expandedRow.classList.contains('show')) {
            const panelContent = createVersionsPanel(game, {
                mainGame: {
                    type: 'main',
                    name: game.name,
                    appid: gameAppId,
                    price: game.price_initial_cents ? {
                        initial: game.price_initial_cents,
                        final: game.price_final_cents,
                        discount_percent: game.discount_percent
                    } : null,
                    is_free: game.is_free,
                    versions: game.versions || [],
                    selectedVersion: game.selectedVersion,
                    selectedVersionData: game.selectedVersionData
                },
                dlcs: game.dlc_data || [],
                allDlcIds: game.dlc_ids || [],
                totalDlcCount: game.dlc_count || 0,
                loadedDlcCount: game.loaded_dlc_count || 0,
                hasMoreDLC: false
            }, expandedRow);
            expandedRow.innerHTML = '';
            expandedRow.appendChild(panelContent);
        }
        
        showStatus(newDLCData.error ? 'Échec de la récupération du DLC' : 'DLC récupéré avec succès', 
                   newDLCData.error ? 'error' : 'success');
    } finally {
        stopLoading();
    }
}

function formatPriceForDisplay(priceCents) {
    if (priceCents === null || priceCents === undefined || priceCents === 0) return '—';
    return (priceCents / 100).toFixed(2) + '€';
}

// MODIFIÉ : Créer le panneau des versions
function createVersionsPanel(game, versionsData, expandedRow) {
    const container = document.createElement('div');
    container.className = 'versions-container';
    
    if (versionsData.error) {
        const errorMsg = document.createElement('div');
        errorMsg.className = 'error-versions';
        errorMsg.textContent = `Erreur: ${versionsData.error}`;
        container.appendChild(errorMsg);
        return container;
    }
    
    if (!versionsData.mainGame) {
        const noDataMsg = document.createElement('div');
        noDataMsg.className = 'loading-versions';
        noDataMsg.textContent = 'Aucune donnée de version disponible';
        container.appendChild(noDataMsg);
        return container;
    }
    
    // Section des versions du jeu
    const versionsSection = document.createElement('div');
    versionsSection.className = 'versions-section';
    
    const versionsTitle = document.createElement('h3');
    versionsTitle.textContent = 'Versions du jeu';
    versionsSection.appendChild(versionsTitle);
    
    // Bouton pour désélectionner la version
    if (game.selectedVersionData) {
        const deselectButton = document.createElement('button');
        deselectButton.className = 'retry-btn';
        deselectButton.style.marginBottom = '12px';
        deselectButton.textContent = 'Désélectionner la version';
        deselectButton.onclick = () => {
            deselectVersion(game.appid);
            // Rafraîchir le panneau
            const panelContent = createVersionsPanel(game, versionsData, expandedRow);
            expandedRow.innerHTML = '';
            expandedRow.appendChild(panelContent);
        };
        versionsSection.appendChild(deselectButton);
    }
    
    if (versionsData.mainGame.versions && versionsData.mainGame.versions.length > 0) {
        versionsData.mainGame.versions.forEach(version => {
            const versionItem = document.createElement('div');
            versionItem.className = 'version-item main-game';
            
            const versionHeader = document.createElement('div');
            versionHeader.className = 'version-header';
            
            const versionCheckbox = document.createElement('input');
            versionCheckbox.type = 'radio';
            versionCheckbox.className = 'version-checkbox';
            versionCheckbox.name = `version-${game.appid}`;
            versionCheckbox.checked = game.selectedVersion === version.packageid;
            versionCheckbox.onchange = () => {
                if (versionCheckbox.checked) {
                    selectVersion(game.appid, version);
                    // Rafraîchir le panneau
                    const panelContent = createVersionsPanel(game, versionsData, expandedRow);
                    expandedRow.innerHTML = '';
                    expandedRow.appendChild(panelContent);
                }
            };
            
            const nameSpan = document.createElement('div');
            nameSpan.className = 'version-name';
            nameSpan.textContent = version.name;
            
            const priceContainer = document.createElement('div');
            priceContainer.className = 'version-price-container';
            
            if (version.is_free_license) {
                const freeBadge = document.createElement('span');
                freeBadge.className = 'version-free';
                freeBadge.textContent = 'GRATUIT';
                priceContainer.appendChild(freeBadge);
            } else if (version.price_in_cents_with_discount !== undefined) {
                const price = version.price_in_cents_with_discount / 100;
                const currentPrice = document.createElement('span');
                currentPrice.className = 'version-current-price';
                currentPrice.textContent = price.toFixed(2) + '€';
                
                priceContainer.appendChild(currentPrice);
                
                if (version.percent_savings > 0) {
                    const discountBadge = document.createElement('span');
                    discountBadge.className = 'version-discount';
                    discountBadge.textContent = `-${version.percent_savings}%`;
                    priceContainer.appendChild(discountBadge);
                }
            } else {
                const naPrice = document.createElement('span');
                naPrice.className = 'price-na';
                naPrice.textContent = 'N/A';
                priceContainer.appendChild(naPrice);
            }
            
            versionHeader.appendChild(versionCheckbox);
            versionHeader.appendChild(nameSpan);
            versionItem.appendChild(versionHeader);
            versionItem.appendChild(priceContainer);
            versionsSection.appendChild(versionItem);
        });
    } else {
        const noVersionsMsg = document.createElement('div');
        noVersionsMsg.className = 'loading-versions';
        noVersionsMsg.textContent = 'Aucune version spécifique disponible pour ce jeu';
        versionsSection.appendChild(noVersionsMsg);
    }
    
    container.appendChild(versionsSection);
    
    // Section DLC
    if (versionsData.totalDlcCount > 0) {
        const dlcSection = document.createElement('div');
        dlcSection.className = 'versions-section';
        
        const dlcTitle = document.createElement('h3');
        dlcTitle.textContent = `DLC (${versionsData.loadedDlcCount}/${versionsData.totalDlcCount})`;
        dlcSection.appendChild(dlcTitle);
        
        if (versionsData.loadedDlcCount < versionsData.totalDlcCount) {
            const progressContainer = document.createElement('div');
            progressContainer.innerHTML = `
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${(versionsData.loadedDlcCount / versionsData.totalDlcCount) * 100}%"></div>
                </div>
                <div class="dlc-stats">Chargement des DLC... ${versionsData.loadedDlcCount}/${versionsData.totalDlcCount}</div>
            `;
            dlcSection.appendChild(progressContainer);
        }
        
        if (versionsData.dlcs && versionsData.dlcs.length > 0) {
            versionsData.dlcs.forEach(dlc => {
                const dlcItem = document.createElement('div');
                dlcItem.className = 'version-item dlc';
                
                const dlcHeader = document.createElement('div');
                dlcHeader.className = 'version-header';
                
                const dlcCheckbox = document.createElement('input');
                dlcCheckbox.type = 'checkbox';
                dlcCheckbox.className = 'version-checkbox';
                dlcCheckbox.checked = dlc.selected || false;
                dlcCheckbox.onchange = () => {
                    const gameIndex = games.findIndex(g => g.appid === game.appid);
                    if (gameIndex !== -1) {
                        const dlcIndex = games[gameIndex].dlc_data?.findIndex(d => d.appid === dlc.appid);
                        if (dlcIndex !== -1 && dlcIndex !== undefined) {
                            games[gameIndex].dlc_data[dlcIndex].selected = dlcCheckbox.checked;
                            saveGamesToLocalStorage();
                            updateSelectionStats();
                        }
                    }
                };
                
                const nameContainer = document.createElement('div');
                nameContainer.className = 'version-name';
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = dlc.name || `DLC ${dlc.appid}`;
                
                if (dlc.error) {
                    nameSpan.style.color = '#ff8c42';
                    nameSpan.title = 'Erreur de chargement - Cliquez pour réessayer';
                    
                    const retryBtn = document.createElement('button');
                    retryBtn.className = 'dlc-retry-btn';
                    retryBtn.textContent = 'Réessayer';
                    retryBtn.onclick = () => retrySingleDLC(game.appid, dlc.appid);
                    
                    nameContainer.appendChild(nameSpan);
                    nameContainer.appendChild(retryBtn);
                } else {
                    nameContainer.appendChild(nameSpan);
                }
                
                const priceContainer = document.createElement('div');
                priceContainer.className = 'version-price-container';
                
                if (dlc.loading) {
                    const loadingSpan = document.createElement('span');
                    loadingSpan.className = 'price-na';
                    loadingSpan.innerHTML = '<span class="loading" style="width: 12px; height: 12px; margin-right: 4px;"></span>Chargement...';
                    priceContainer.appendChild(loadingSpan);
                } else if (dlc.error) {
                    const errorBadge = document.createElement('span');
                    errorBadge.className = 'version-error';
                    errorBadge.textContent = 'ERREUR';
                    priceContainer.appendChild(errorBadge);
                } else if (dlc.is_free) {
                    const freeBadge = document.createElement('span');
                    freeBadge.className = 'version-free';
                    freeBadge.textContent = 'GRATUIT';
                    priceContainer.appendChild(freeBadge);
                } else if (dlc.price_overview) {
                    const finalPrice = formatPriceForDisplay(dlc.price_overview.final);
                    const initialPrice = formatPriceForDisplay(dlc.price_overview.initial);
                    
                    if (dlc.price_overview.discount_percent > 0) {
                        const oldPrice = document.createElement('span');
                        oldPrice.className = 'version-old-price';
                        oldPrice.textContent = initialPrice;
                        
                        const currentPrice = document.createElement('span');
                        currentPrice.className = 'version-current-price';
                        currentPrice.textContent = finalPrice;
                        
                        const discountBadge = document.createElement('span');
                        discountBadge.className = 'version-discount';
                        discountBadge.textContent = `-${dlc.price_overview.discount_percent}%`;
                        
                        priceContainer.appendChild(oldPrice);
                        priceContainer.appendChild(currentPrice);
                        priceContainer.appendChild(discountBadge);
                    } else {
                        const currentPrice = document.createElement('span');
                        currentPrice.className = 'version-current-price';
                        currentPrice.textContent = finalPrice;
                        priceContainer.appendChild(currentPrice);
                    }
                } else {
                    const naPrice = document.createElement('span');
                    naPrice.className = 'price-na';
                    naPrice.textContent = 'N/A';
                    priceContainer.appendChild(naPrice);
                }
                
                dlcHeader.appendChild(dlcCheckbox);
                dlcHeader.appendChild(nameContainer);
                dlcItem.appendChild(dlcHeader);
                dlcItem.appendChild(priceContainer);
                dlcSection.appendChild(dlcItem);
            });
        }
        
        container.appendChild(dlcSection);
        
    } else {
        const noDlcSection = document.createElement('div');
        noDlcSection.className = 'versions-section';
        
        const noDlcTitle = document.createElement('h3');
        noDlcTitle.textContent = 'DLC';
        noDlcSection.appendChild(noDlcTitle);
        
        const noDlcMsg = document.createElement('div');
        noDlcMsg.className = 'loading-versions';
        noDlcMsg.textContent = 'Aucun DLC disponible pour ce jeu';
        noDlcSection.appendChild(noDlcMsg);
        
        container.appendChild(noDlcSection);
    }
    
    return container;
}

async function fetchAndAddGame(appId){
    if (!appId || appId <= 0) {
        showStatus('ID invalide', 'error');
        return;
    }
    
    if (hasGame(appId)){
        showStatus(`Le jeu ${appId} est déjà présent`, 'warning');
        return;
    }
    
    const btn = document.getElementById('addGameBtn');
    const originalText = btn.textContent;
    btn.textContent = 'Chargement...';
    btn.disabled = true;
    startLoading();
    
    try {
        showStatus('Récupération des données du jeu...', 'loading');
        
        const basicGameData = await fetchBasicGameData(appId);
        
        if (basicGameData) {
            basicGameData.dlc_loading = false;
            games.push(basicGameData);
            addGameRow(basicGameData);
            
            // Charger les versions en arrière-plan
            setTimeout(async () => {
                try {
                    const gameIndex = games.findIndex(g => g.appid === appId);
                    if (gameIndex !== -1) {
                        const versions = await fetchGamePackages(appId);
                        games[gameIndex].versions = versions;
                        saveGamesToLocalStorage();
                        
                        if (versions.length > 0) {
                            showStatus(`${basicGameData.name} - ${versions.length} version(s) chargée(s)`, 'success');
                        }
                    }
                } catch (error) {
                    // Ignorer les erreurs de chargement des versions
                }
            }, 500);
            
            if (basicGameData.dlc_count > 0) {
                const gameIndex = games.findIndex(g => g.appid === appId);
                if (gameIndex !== -1) {
                    games[gameIndex].dlc_loading = true;
                    
                    // Démarrer le chargement en arrière-plan
                    setTimeout(() => {
                        loadDLCsProgressively(
                            basicGameData.dlc_ids,
                            (loaded, total) => {
                                games[gameIndex].loaded_dlc_count = loaded;
                                updateDLCBadge(appId, loaded, total);
                            },
                            (batch) => {
                                if (!games[gameIndex].dlc_data) games[gameIndex].dlc_data = [];
                                games[gameIndex].dlc_data.push(...batch);
                            }
                        ).then(dlcDetails => {
                            games[gameIndex].dlc_data = dlcDetails;
                            games[gameIndex].dlc_loading = false;
                            games[gameIndex].loaded_dlc_count = dlcDetails.filter(d => !d.error).length;
                            saveGamesToLocalStorage();
                            
                            const errorCount = dlcDetails.filter(d => d.error).length;
                            const successCount = dlcDetails.length - errorCount;
                            if (errorCount > 0) {
                                showStatus(`${basicGameData.name} - ${successCount} DLC chargés, ${errorCount} erreur(s)`, 'warning');
                            }
                        });
                    }, 100);
                }
            }
            
            document.getElementById('gameIdInput').value = '';
            showStatus(`${basicGameData.name} ajouté`, 'success');
            updateSelectionStats();
        } else {
            showStatus('Échec de la récupération des données', 'error');
        }
    } catch (error) {
        console.error('Erreur:', error);
        showStatus('Erreur lors de l\'ajout', 'error');
    } finally {
        btn.textContent = originalText;
        btn.disabled = false;
        stopLoading();
    }
}

async function retryGame(appId) {
    startLoading();
    try {
        const index = games.findIndex(g => 
            String(g.appid) === String(appId) || 
            String(g.steam_appid) === String(appId)
        );
        
        if (index !== -1) {
            showStatus(`Nouvelle tentative pour ${appId}...`, 'loading');
            const gameData = await fetchGameDataWithPreload(appId);
            
            if (gameData && !gameData.unavailable) {
                games[index] = gameData;
                saveGamesToLocalStorage();
                refreshGrid();
                showStatus(`Jeu ${appId} mis à jour`, 'success');
            }
        }
    } finally {
        stopLoading();
    }
}

function formatPrice(cents){
    if (cents === null || cents === undefined) return '—';
    return (cents/100).toFixed(2) + '€';
}

function formatPriceForFree(isFree, cents) {
    if (isFree) return 'Gratuit';
    if (cents === null || cents === undefined) return '—';
    return formatPrice(cents);
}

// MODIFIÉ : Ajouter une ligne de jeu
function addGameRow(game){
    const grid = document.getElementById('gamesGrid');
    
    const menuCell = document.createElement('div');
    menuCell.className = 'menu-container';
    
    const expandBtn = document.createElement('button');
    expandBtn.className = 'expand-btn';
    expandBtn.innerHTML = '▸';
    expandBtn.title = 'Voir les versions et DLC';
    expandBtn.setAttribute('data-appid', game.appid || game.steam_appid);
    
    if (game.dlc_count > 0) {
        const dlcBadge = document.createElement('span');
        dlcBadge.className = 'dlc-progress-badge';
        
        const loadedWithoutError = game.dlc_data ? game.dlc_data.filter(d => !d.error).length : 0;
        const displayCount = game.loaded_dlc_count < game.dlc_count ? 
            `${loadedWithoutError}/${game.dlc_count}` : loadedWithoutError;
        
        dlcBadge.textContent = displayCount;
        
        if (loadedWithoutError < game.dlc_count) {
            dlcBadge.style.background = '#2a4758';
            if (game.dlc_loading) {
                const loadingIndicator = document.createElement('div');
                loadingIndicator.className = 'dlc-loading-indicator';
                expandBtn.appendChild(loadingIndicator);
            }
        } else {
            dlcBadge.style.background = '#1a7f57';
        }
        
        expandBtn.appendChild(dlcBadge);
    }
    
    const nameCell = document.createElement('div'); 
    nameCell.className='name-cell';
    nameCell.setAttribute('data-game-id', game.appid || game.steam_appid);
    
    const bgImage = document.createElement('div');
    bgImage.className = 'name-bg-image';
    bgImage.style.backgroundImage = `url('${game.header_image}')`;
    bgImage.onerror = function() {
        this.style.backgroundImage = `url('https://store.cloudflare.steamstatic.com/public/shared/images/header/globalheader_logo.png')`;
    };
    
    const nameContent = document.createElement('div');
    nameContent.className = 'name-content';
    
    const titleContainer = document.createElement('div');
    titleContainer.className = 'game-title';
    
    const gameCheckbox = document.createElement('input');
    gameCheckbox.type = 'checkbox';
    gameCheckbox.className = 'game-checkbox';
    gameCheckbox.checked = game.selected || false;
    gameCheckbox.onchange = () => {
        const gameIndex = games.findIndex(g => g.appid === game.appid);
        if (gameIndex !== -1) {
            games[gameIndex].selected = gameCheckbox.checked;
            saveGamesToLocalStorage();
            updateSelectionStats();
        }
    };
    
    const titleText = document.createElement('span');
    
    // MODIFICATION : Afficher le nom de la version sélectionnée si elle existe
    if (game.selectedVersionData && game.selectedVersionData.name) {
        titleText.textContent = game.selectedVersionData.name;
        // Ajouter un indicateur que c'est une version
        const versionIndicator = document.createElement('span');
        versionIndicator.className = 'version-indicator';
        versionIndicator.textContent = 'Version';
        titleContainer.appendChild(titleText);
        titleContainer.appendChild(versionIndicator);
    } else {
        titleText.textContent = game.name || 'Inconnu';
        titleContainer.appendChild(titleText);
    }
    
    if (game.unavailable) {
        titleText.style.color = game.offline ? '#ffa366' : '#ff6b6b';
        titleText.title = game.offline ? 'Connexion échouée' : 'Jeu indisponible';
    }
    
    titleContainer.appendChild(gameCheckbox);
    titleContainer.appendChild(titleText);
    
    const meta = document.createElement('div'); 
    meta.className='meta';
    
    let metaText = `ID: ${game.appid || game.steam_appid || '—'}`;
    if (game.versions && game.versions.length > 0) {
        metaText += ` | Versions: ${game.versions.length}`;
    }
    if (game.dlc_count > 0) {
        const loadedWithoutError = game.dlc_data ? game.dlc_data.filter(d => !d.error).length : 0;
        metaText += ` | DLC: ${loadedWithoutError || 0}/${game.dlc_count}`;
        if (game.dlc_loading || loadedWithoutError < game.dlc_count) {
            metaText += ' (chargement...)';
        }
    }
    if (game.last_updated) {
        const date = new Date(game.last_updated);
        metaText += ` | Maj: ${date.toLocaleDateString('fr-FR')}`;
    }
    
    meta.textContent = metaText;
    
    const actions = document.createElement('div');
    actions.style.display = 'flex';
    actions.style.gap = '4px';
    
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = 'Supprimer';
    deleteBtn.onclick = function() {
        removeGame(game.appid || game.steam_appid);
    };
    
    actions.appendChild(deleteBtn);
    
    if (game.unavailable || game.offline) {
        const retryBtn = document.createElement('button');
        retryBtn.className = 'retry-btn';
        retryBtn.textContent = 'Réessayer';
        retryBtn.onclick = function() {
            retryGame(game.appid || game.steam_appid);
        };
        actions.appendChild(retryBtn);
    }
    
    nameContent.appendChild(titleContainer); 
    nameContent.appendChild(meta);
    nameContent.appendChild(actions);
    
    nameCell.appendChild(bgImage);
    nameCell.appendChild(nameContent);
    
    // MODIFICATION : Afficher les prix de la version sélectionnée si elle existe
    const oldCell = document.createElement('div'); 
    oldCell.className='cell';
    const oldPrice = document.createElement('div'); 

    if (game.selectedVersionData) {
        // Utiliser les prix de la version sélectionnée
        if (game.selectedVersionData.is_free_license) {
            oldPrice.className = 'price-current';
            oldPrice.textContent = '—';
        } else if (game.selectedVersionData.price_in_cents_with_discount !== undefined) {
            const price = game.selectedVersionData.price_in_cents_with_discount / 100;
            oldPrice.className = 'price-current';
            oldPrice.textContent = formatPrice(game.selectedVersionData.price_in_cents_with_discount);
        } else {
            oldPrice.className = '';
            oldPrice.textContent = '—';
        }
    } else if (game.is_free) {
        oldPrice.className = 'price-current';
        oldPrice.textContent = '—';
    } else if (game.price_initial_cents !== null && game.price_initial_cents !== undefined) {
        const initial = Number(game.price_initial_cents);
        const final = (game.price_final_cents !== null && game.price_final_cents !== undefined) ? Number(game.price_final_cents) : null;

        if (final !== null && initial === final) {
            oldPrice.className = 'price-current';
        } else {
            oldPrice.className = 'price-old';
        }

        oldPrice.textContent = formatPrice(initial);
    } else {
        oldPrice.className = '';
        oldPrice.textContent = '—';
    }
    oldCell.appendChild(oldPrice);
    
    const currentCell = document.createElement('div'); 
    currentCell.className='cell';
    const curPrice = document.createElement('div'); 
    curPrice.className='price-current';
    
    if (game.unavailable) {
        curPrice.textContent = game.offline ? 'Hors ligne' : 'Indisponible';
        curPrice.style.color = game.offline ? '#ffa366' : '#ff6b6b';
    } else if (game.selectedVersionData) {
        // Utiliser les prix de la version sélectionnée
        if (game.selectedVersionData.is_free_license) {
            curPrice.textContent = 'Gratuit';
        } else if (game.selectedVersionData.price_in_cents_with_discount !== undefined) {
            const price = game.selectedVersionData.price_in_cents_with_discount / 100;
            curPrice.textContent = price.toFixed(2) + '€';
        } else {
            curPrice.textContent = 'N/A';
        }
    } else {
        curPrice.textContent = formatPriceForFree(game.is_free, game.price_final_cents);
    }
    currentCell.appendChild(curPrice);
    
    const discCell = document.createElement('div'); 
    discCell.className='cell';
    const disc = document.createElement('div'); 
    disc.className='discount';
    
    if (game.unavailable) {
        disc.textContent = game.offline ? 'ERR' : 'N/A';
        disc.style.background = game.offline ? '#5c5c2e' : '#5c2e2e';
    } else if (game.selectedVersionData) {
        // Utiliser la réduction de la version sélectionnée
        if (game.selectedVersionData.is_free_license) {
            disc.textContent = 'FREE';
            disc.style.background = '#2a4758';
        } else if (game.selectedVersionData.percent_savings > 0) {
            disc.textContent = `-${game.selectedVersionData.percent_savings}%`;
            disc.style.background = '#1a7f57';
        } else {
            disc.textContent = '0%';
            disc.style.background = 'var(--muted)';
        }
    } else if (game.is_free) {
        disc.textContent = 'FREE';
        disc.style.background = '#2a4758';
    } else if (game.discount_percent > 0) {
        disc.textContent = `-${game.discount_percent}%`;
        disc.style.background = '#1a7f57';
    } else {
        disc.textContent = '0%';
        disc.style.background = 'var(--muted)';
    }
    
    discCell.appendChild(disc);
    
    const expandedRow = document.createElement('div');
    expandedRow.className = 'expanded-row';
    expandedRow.id = `expanded-${game.appid || game.steam_appid}`;
    
    let isRowLoading = false;
    let hasRowLoaded = false;
    let currentVersionsData = null;
    let progressInterval = null;
    
    expandBtn.addEventListener('click', async function(e) {
        e.stopPropagation();
        
        const isExpanded = expandedRow.classList.contains('show');
        
        document.querySelectorAll('.expanded-row.show').forEach(row => {
            if (row.id !== expandedRow.id) {
                row.classList.remove('show');
                const otherBtn = row.previousElementSibling?.querySelector('.expand-btn');
                if (otherBtn) otherBtn.innerHTML = '▸';
            }
        });
        
        if (!isExpanded) {
            expandedRow.classList.add('show');
            expandBtn.innerHTML = '▾';
            
            if (!hasRowLoaded && !isRowLoading) {
                isRowLoading = true;
                
                if (game.dlc_data && game.dlc_data.length === game.dlc_count && game.dlc_count > 0) {
                    currentVersionsData = {
                        mainGame: {
                            type: 'main',
                            name: game.name,
                            appid: game.appid || game.steam_appid,
                            price: game.price_initial_cents ? {
                                initial: game.price_initial_cents,
                                final: game.price_final_cents,
                                discount_percent: game.discount_percent
                            } : null,
                            is_free: game.is_free,
                            versions: game.versions || [],
                            selectedVersion: game.selectedVersion,
                            selectedVersionData: game.selectedVersionData
                        },
                        dlcs: game.dlc_data || [],
                        allDlcIds: game.dlc_ids || [],
                        totalDlcCount: game.dlc_count || 0,
                        loadedDlcCount: game.loaded_dlc_count || 0,
                        hasMoreDLC: false 
                    };
                    
                    expandedRow.innerHTML = '';
                    const panelContent = createVersionsPanel(game, currentVersionsData, expandedRow);
                    expandedRow.appendChild(panelContent);
                    hasRowLoaded = true;
                    isRowLoading = false;
                    return;
                }
                
                expandedRow.innerHTML = '<div class="loading-versions">Chargement des DLC...</div>';
                
                try {
                    progressInterval = setInterval(() => {
                        const gameIndex = games.findIndex(g => g.appid === game.appid);
                        if (gameIndex !== -1 && expandedRow.classList.contains('show')) {
                            const currentGame = games[gameIndex];
                            if (currentGame.dlc_loading || currentGame.loaded_dlc_count < currentGame.dlc_count) {
                                const progressEl = expandedRow.querySelector('.progress-fill');
                                const statsEl = expandedRow.querySelector('.dlc-stats');
                                if (progressEl && statsEl) {
                                    const progress = (currentGame.loaded_dlc_count / currentGame.dlc_count) * 100;
                                    progressEl.style.width = `${progress}%`;
                                    statsEl.textContent = `Chargement des DLC... ${currentGame.loaded_dlc_count}/${currentGame.dlc_count}`;
                                }
                            }
                        }
                    }, 500);
                    
                    currentVersionsData = await fetchGameVersions(game.appid || game.steam_appid, (loaded, total) => {
                        if (expandedRow.classList.contains('show')) {
                            const progressEl = expandedRow.querySelector('.progress-fill');
                            const statsEl = expandedRow.querySelector('.dlc-stats');
                            if (progressEl && statsEl) {
                                const progress = (loaded / total) * 100;
                                progressEl.style.width = `${progress}%`;
                                statsEl.textContent = `Chargement des DLC... ${loaded}/${total}`;
                            }
                        }
                    });
                    
                    clearInterval(progressInterval);
                    expandedRow.innerHTML = '';
                    const panelContent = createVersionsPanel(game, currentVersionsData, expandedRow);
                    expandedRow.appendChild(panelContent);
                    hasRowLoaded = true;
                } catch (error) {
                    clearInterval(progressInterval);
                    expandedRow.innerHTML = '<div class="error-versions">Erreur de chargement des DLC</div>';
                    console.error('Erreur:', error);
                }
                
                isRowLoading = false;
            } else if (hasRowLoaded && currentVersionsData) {
                const gameIndex = games.findIndex(g => g.appid === game.appid);
                if (gameIndex !== -1) {
                    const currentGame = games[gameIndex];
                    if (currentGame.loaded_dlc_count > currentVersionsData.loadedDlcCount) {
                        currentVersionsData.loadedDlcCount = currentGame.loaded_dlc_count;
                        currentVersionsData.dlcs = currentGame.dlc_data || [];
                    }
                }
                
                expandedRow.innerHTML = '';
                const panelContent = createVersionsPanel(game, currentVersionsData, expandedRow);
                expandedRow.appendChild(panelContent);
            }
        } else {
            expandedRow.classList.remove('show');
            expandBtn.innerHTML = '▸';
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
        }
    });
    
    menuCell.appendChild(expandBtn);
    
    grid.appendChild(menuCell);      
    grid.appendChild(nameCell);
    grid.appendChild(oldCell);
    grid.appendChild(currentCell);
    grid.appendChild(discCell);
    
    grid.appendChild(expandedRow);
}

function removeGame(appId) {
    const index = games.findIndex(g => 
        String(g.appid) === String(appId) || 
        String(g.steam_appid) === String(appId)
    );
    
    if (index !== -1) {
        games.splice(index, 1);
        saveGamesToLocalStorage();
        refreshGrid();
        showStatus('Jeu supprimé', 'success');
        updateSelectionStats();
    }
}

function refreshGrid() {
    const grid = document.getElementById('gamesGrid');
    grid.innerHTML = '';
    games.forEach(addGameRow);
    updateSortIndicators();
}

function updateSortIndicators() {
    document.querySelectorAll('.sortable .sort-indicator').forEach(indicator => {
        indicator.textContent = '';
    });
    
    const activeHeader = document.querySelector(`.sortable[data-sort="${currentSort.field}"] .sort-indicator`);
    if (activeHeader) {
        activeHeader.textContent = currentSort.direction === 'asc' ? '▲' : '▼';
    }
}

function sortGames() {
    games.sort((a, b) => {
        let valueA, valueB;
        
        switch (currentSort.field) {
            case 'name':
                // Utiliser le nom de la version sélectionnée si disponible
                valueA = a.selectedVersionData ? a.selectedVersionData.name.toLowerCase() : a.name?.toLowerCase() || '';
                valueB = b.selectedVersionData ? b.selectedVersionData.name.toLowerCase() : b.name?.toLowerCase() || '';
                break;
                
            case 'original-price':
                // Utiliser le prix de la version sélectionnée si disponible
                if (a.selectedVersionData) {
                    valueA = a.selectedVersionData.is_free_license ? 0 : a.selectedVersionData.price_in_cents_with_discount || Infinity;
                } else {
                    valueA = a.price_initial_cents || (a.is_free ? 0 : Infinity);
                }
                if (b.selectedVersionData) {
                    valueB = b.selectedVersionData.is_free_license ? 0 : b.selectedVersionData.price_in_cents_with_discount || Infinity;
                } else {
                    valueB = b.price_initial_cents || (b.is_free ? 0 : Infinity);
                }
                break;
                
            case 'current-price':
                // Utiliser le prix de la version sélectionnée si disponible
                if (a.selectedVersionData) {
                    valueA = a.selectedVersionData.is_free_license ? 0 : a.selectedVersionData.price_in_cents_with_discount || Infinity;
                } else {
                    valueA = a.price_final_cents || (a.is_free ? 0 : Infinity);
                }
                if (b.selectedVersionData) {
                    valueB = b.selectedVersionData.is_free_license ? 0 : b.selectedVersionData.price_in_cents_with_discount || Infinity;
                } else {
                    valueB = b.price_final_cents || (b.is_free ? 0 : Infinity);
                }
                break;
                
            case 'discount':
                // Utiliser la réduction de la version sélectionnée si disponible
                if (a.selectedVersionData) {
                    valueA = a.selectedVersionData.percent_savings || 0;
                } else {
                    valueA = a.discount_percent || 0;
                }
                if (b.selectedVersionData) {
                    valueB = b.selectedVersionData.percent_savings || 0;
                } else {
                    valueB = b.discount_percent || 0;
                }
                break;
                
            default:
                return 0;
        }
        
        if (currentSort.direction === 'asc') {
            return valueA > valueB ? 1 : valueA < valueB ? -1 : 0;
        } else {
            return valueA < valueB ? 1 : valueA > valueB ? -1 : 0;
        }
    });
    
    refreshGrid();
}

function updateSelectionStats() {
    const totalGames = games.length;
    const selectedGames = games.filter(g => g.selected).length;
    
    let totalDLCs = 0;
    let selectedDLCs = 0;
    let selectedVersions = 0;
    
    games.forEach(game => {
        totalDLCs += game.dlc_count || 0;
        if (game.dlc_data) {
            selectedDLCs += game.dlc_data.filter(d => d.selected).length;
        }
        if (game.selectedVersion) {
            selectedVersions++;
        }
    });
    
    const statsEl = document.getElementById('selectionStats');
    statsEl.innerHTML = `
        <span>Jeux: ${selectedGames}/${totalGames}</span>
        <span>Versions: ${selectedVersions}</span>
        <span>DLC: ${selectedDLCs}/${totalDLCs}</span>
    `;
}

function saveGamesToLocalStorage() {
    localStorage.setItem('steamGames', JSON.stringify(games));
    localStorage.setItem('sortSettings', JSON.stringify(currentSort));
}

function loadGamesFromLocalStorage() {
    const savedGames = localStorage.getItem('steamGames');
    if (savedGames) {
        try {
            const parsedGames = JSON.parse(savedGames);
            games.length = 0;
            parsedGames.forEach(game => games.push(game));
            return true;
        } catch (e) {
            console.error('Erreur de chargement:', e);
            localStorage.removeItem('steamGames');
        }
    }
    
    const savedSort = localStorage.getItem('sortSettings');
    if (savedSort) {
        try {
            currentSort = JSON.parse(savedSort);
        } catch (e) {
            console.error('Erreur de chargement du tri:', e);
        }
    }
    
    return false;
}

function clearAllGames() {
    if (games.length === 0) {
        showStatus('Aucun jeu à supprimer', 'warning');
        return;
    }
    
    if (confirm(`Voulez-vous vraiment supprimer tous les jeux (${games.length}) ?`)) {
        games.length = 0;
        localStorage.removeItem('steamGames');
        refreshGrid();
        updateSelectionStats();
        showStatus('Tous les jeux ont été supprimés', 'success');
    }
}

document.addEventListener('DOMContentLoaded', ()=>{
    // Initialiser le GIF Pepe
    updatePepeGif();
    
    if (loadGamesFromLocalStorage()) {
        showStatus(`${games.length} jeu(x) chargé(s)`, 'success');
        
        games.forEach(game => {
            const gameToShow = {
                ...game,
                dlc_data: game.dlc_data || [],
                dlc_loading: false
            };
            addGameRow(gameToShow);
        });
        
        sortGames();
        updateSelectionStats();
        
        // Charger les versions et DLC en arrière-plan
        setTimeout(() => {
            games.forEach(async (game) => {
                // Charger les versions si nécessaire
                if (!game.versions || game.versions.length === 0) {
                    try {
                        const versions = await fetchGamePackages(game.appid);
                        const gameIndex = games.findIndex(g => g.appid === game.appid);
                        if (gameIndex !== -1) {
                            games[gameIndex].versions = versions;
                            saveGamesToLocalStorage();
                        }
                    } catch (error) {
                        // Ignorer les erreurs
                    }
                }
                
                // Charger les DLC si nécessaire
                if (game.dlc_count > 0 && (!game.dlc_data || game.dlc_data.length < game.dlc_count)) {
                    game.dlc_loading = true;
                    updateDLCBadge(game.appid, game.loaded_dlc_count || 0, game.dlc_count);
                    
                    const dlcDetails = await loadDLCsProgressively(
                        game.dlc_ids || [],
                        (loaded, total) => {
                            game.loaded_dlc_count = loaded;
                            updateDLCBadge(game.appid, loaded, total);
                        },
                        (batch) => {
                            if (!game.dlc_data) game.dlc_data = [];
                            game.dlc_data.push(...batch);
                        }
                    );
                    
                    game.dlc_data = dlcDetails;
                    game.loaded_dlc_count = dlcDetails.filter(d => !d.error).length;
                    game.dlc_loading = false;
                    saveGamesToLocalStorage();
                    updateDLCBadge(game.appid, game.loaded_dlc_count, game.dlc_count);
                }
            });
        }, 1000);
    }
    
    const btn = document.getElementById('addGameBtn');
    const input = document.getElementById('gameIdInput');
    const clearBtn = document.getElementById('clearBtn');
    
    btn.addEventListener('click', ()=>{
        const id = input.value && input.value.trim();
        if (!id) {
            showStatus('Entrez un ID Steam valide', 'error');
            return;
        }
        fetchAndAddGame(id);
    });
    
    input.addEventListener('keydown', (e)=>{ 
        if (e.key === 'Enter'){ 
            btn.click(); 
        } 
    });
    
    clearBtn.addEventListener('click', clearAllGames);
    
    // Ajouter les gestionnaires de tri
    document.querySelectorAll('.sortable').forEach(header => {
        header.addEventListener('click', () => {
            const field = header.dataset.sort;
            
            if (currentSort.field === field) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.field = field;
                currentSort.direction = 'asc';
            }
            
            sortGames();
            saveGamesToLocalStorage();
        });
    });
    
    input.focus();
});

window.SteamAPI = {
    getSteamGameData: getSteamGameDataWithPreload,
    loadDLCsProgressively,
    fetchGameDataWithPreload,
    fetchGameVersions,
    retrySingleDLC,
    updatePepeGif,
    sortGames
};
    </script>
</body>
</html>